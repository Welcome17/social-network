{"version":3,"sources":["components/Dialogs/DialogItems/DialogItem.jsx","components/Dialogs/Dialogs.jsx","hoc/withAuthRedirect.js","components/Dialogs/DialogsContainer.jsx"],"names":["DialogItem","props","path","id","className","s","dialog","src","profileImage","to","name","maxLength300","maxLengthCreator","AddMessageFormRedux","reduxForm","form","messageContainer","onSubmit","handleSubmit","component","Textarea","placeholder","validate","required","Dialogs","dialogElements","dialogsPage","dialogs","map","d","messagesElement","messages","m","message","sender","dialogsItems","values","sendMessageClick","newMessageBody","mapStateToPropsTForRedirect","state","isAuth","auth","withAuthRedirect","Component","RedirectComponent","console","log","this","React","connect","compose","dispatch","addMessageActionCreator"],"mappings":"wGAAA,oDAsBeA,IAhBI,SAACC,GAChB,IAAIC,EAAO,YAAcD,EAAME,GAE/B,OACI,yBAAKC,UAAWC,IAAEC,QACd,6BACI,yBAAKC,IAAKN,EAAMO,gBAEpB,6BACI,kBAAC,IAAD,CAASC,GAAIP,GAAb,IAAsBD,EAAMS,U,iCCf5C,uFA4DIC,EAAeC,YAAiB,KAgB9BC,EAAsBC,YACxB,CACAC,KAAK,wBAFmBD,EAdL,SAACb,GACpB,OACI,0BAAMG,UAAWC,IAAEW,iBAAkBC,SAAUhB,EAAMiB,cACjD,6BACI,kBAAC,IAAD,CAAOC,UAAWC,IAAUV,KAAM,iBAAkBW,YAAa,qBAAsBC,SAAU,CAACC,IAAUZ,MAGhH,6BACI,6CAaDa,IAzEC,SAACvB,GAIb,IAAIwB,EAAiBxB,EAAMyB,YAAYC,QAAQC,KAAI,SAACC,GAAD,OAAO,kBAAC,IAAD,CAAY1B,GAAI0B,EAAE1B,GAAIO,KAAMmB,EAAEnB,KAClBF,aAAcqB,EAAErB,kBAClFsB,EAAkB7B,EAAMyB,YAAYK,SAASH,KAAI,SAAAI,GAAC,OAAI,kBAAC,IAAD,CAAS7B,GAAI6B,EAAE7B,GAAI8B,QAASD,EAAEC,QAASC,OAAQF,EAAEE,OACxC1B,aAAcwB,EAAExB,kBA4BnF,OACI,yBAAKJ,UAAWC,IAAEsB,SACd,yBAAKvB,UAAWC,IAAE8B,cACbV,GAEL,yBAAKrB,UAAWC,IAAE0B,UACbD,GAEL,kBAACjB,EAAD,CAAqBI,SAZT,SAACmB,GACjBnC,EAAMoC,iBAAiBD,EAAOE,sB,gJCpClCC,EAA8B,SAACC,GAAD,MAAY,CAC1CC,OAAQD,EAAME,KAAKD,SAGVE,EAAmB,SAACC,GAAe,IACtCC,EADqC,uKAInC,OADAC,QAAQC,IAAIC,KAAK/C,OACZ+C,KAAK/C,MAAMwC,OAET,kBAACG,EAAcI,KAAK/C,OAFI,kBAAC,IAAD,CAAUQ,GAAI,eAJV,GACXwC,IAAML,WAYtC,OADqCM,YAAQX,EAARW,CAAqCL,K,iCCtB9E,yEAoDeM,sBACXD,aAtBkB,SAACV,GACnB,MAAO,CAGHd,YAAac,EAAMd,gBAIF,SAAC0B,GACtB,MAAO,CACHf,iBAAkB,SAACC,GACfc,EAASC,YAAwBf,SAYzCK,IAFWQ,CAId3B","file":"static/js/4.c156ac19.chunk.js","sourcesContent":["import React from 'react';\r\nimport s from './../Dialogs.module.css';\r\nimport {NavLink} from \"react-router-dom\";\r\nimport Message from \"../Messages/Message\";\r\n\r\n\r\nconst DialogItem = (props) => {\r\n    let path = \"/dialogs/\" + props.id\r\n\r\n    return (\r\n        <div className={s.dialog}>\r\n            <div>\r\n                <img src={props.profileImage} />\r\n            </div>\r\n            <div>\r\n                <NavLink to={path}> { props.name }</NavLink>\r\n            </div>\r\n        </div>\r\n\r\n    )\r\n}\r\n\r\nexport default DialogItem;","import React from 'react';\r\nimport s from './Dialogs.module.css';\r\nimport DialogItem from \"./DialogItems/DialogItem\";\r\nimport Message from \"./Messages/Message\";\r\n\r\nimport {Field, reduxForm} from \"redux-form\";\r\nimport {Textarea} from \"../common/FormsControls/FormsControls\";\r\nimport {maxLengthCreator, required} from \"../../utils/validator\";\r\n\r\n\r\nconst Dialogs = (props) => {\r\n\r\n    /*let state = props.dialogsPage;*/\r\n\r\n    let dialogElements = props.dialogsPage.dialogs.map((d) => <DialogItem id={d.id} name={d.name}\r\n                                                                          profileImage={d.profileImage}/>); //метод map - это страндартный метод любого массива. Он перебирает все данные массива и изменяет их по заданному шаблону. Метод map принимает значение стрелочной функции с передаваемым в нее параметром. Передававемым параметром является Элемент изменяемого массива. Т.е., обращаесь в передаваемой переменной ты образается к каждому элементу изменяемого массива. В теле функции прописываем что должны получить в результате для каждого 1-го элемента массива.\r\n    let messagesElement = props.dialogsPage.messages.map(m => <Message id={m.id} message={m.message} sender={m.sender}\r\n                                                                       profileImage={m.profileImage}/>); //метод map - это страндартный метод любого массива. Он перебирает все данные массива и изменяет их по заданному шаблону. Метод map принимает значение стрелочной функции с передаваемым в нее параметром. Передававемым параметром является Элемент изменяемого массива. Т.е., обращаесь в передаваемой переменной ты образается к каждому элементу изменяемого массива. В теле функции прописываем что должны получить в результате для каждого 1-го элемента массива.\r\n\r\n    /*let newMessageElement = React.createRef(); /* Получение данных со строницы. Создаем переменную и присваеваем ей React.createRef(). Приваеваем эту переменную элемену HTML аналогично id='', но следующим синтаксисом ref={newPostElement}. После этого данная переменная будет содержать в себе элемент HTML и можно ображаться к его значению value через синтаксис newPostElement.current.value */\r\n\r\n  /*  let onSendMessageClick = () => {\r\n        /!*let text = newMessageElement.current.value;*!/ /!*Заменил эту строку образением в props.state.newMessageBody, чтобы избежть использование ссылок на элемент через React.createRef() - ef={newMessageElement} *!/\r\n        let text = props.state.newMessageBody;\r\n        if (text == '') {\r\n            alert('Enter the message text, please');\r\n\r\n        } else {\r\n            props.sendMessageClick()\r\n        }\r\n        /!*props.addMessage();*!/\r\n    }*/\r\n\r\n    /*let onMessageChange = (eventObject) => {\r\n        /!*let text = newMessageElement.current.value;*!/ /!*Заменил эту строку образением в event.target.value, чтобы избежть использование ссылок на элемент через React.createRef() - ef={newMessageElement} *!/\r\n        let text = eventObject.target.value; /!* при срабатывании onChange в элементе textarea в вызываемую функцию передается кто вызвал эту функцию в переменную eventObject, поэтому можно обратиться textarea через метод target и взять у нее value*!/\r\n        /!*props.updateNewMessageText(text);*!/\r\n        /!*props.dispatch(updateNewMessageTextActionCreator(text))*!/\r\n        props.updateNewMessageText(text);\r\n    }*/\r\n\r\n    let addNewMessage = (values) => {\r\n        props.sendMessageClick(values.newMessageBody);\r\n    }\r\n\r\n    return (\r\n        <div className={s.dialogs}>\r\n            <div className={s.dialogsItems}>\r\n                {dialogElements}\r\n            </div>\r\n            <div className={s.messages}>\r\n                {messagesElement}\r\n            </div>\r\n            <AddMessageFormRedux onSubmit={addNewMessage}/>\r\n\r\n        </div>\r\n    )\r\n}\r\n\r\n\r\nlet maxLength300 = maxLengthCreator(300);\r\n\r\nconst AddMessageForm = (props) => {\r\n    return (\r\n        <form className={s.messageContainer} onSubmit={props.handleSubmit}>\r\n            <div>\r\n                <Field component={Textarea} name={\"newMessageBody\"} placeholder={\"enter your message\"} validate={[required, maxLength300]}/>\r\n            </div>\r\n\r\n            <div>\r\n                <button>Send</button>\r\n            </div>\r\n        </form>\r\n    )\r\n}\r\n\r\nconst AddMessageFormRedux = reduxForm(\r\n    {\r\n    form:\"dialogAddMessageForm\"\r\n    }\r\n\r\n)(AddMessageForm)\r\n\r\nexport default Dialogs;","import React, {Component} from \"react\";\r\nimport {Redirect} from \"react-router\";\r\nimport Dialogs from \"../components/Dialogs/Dialogs\";\r\nimport connect from \"react-redux/es/connect/connect\";\r\n\r\n\r\nlet mapStateToPropsTForRedirect = (state) => ({ /* Если функция является объектом, то нужно после стрелки ставить сперва ( скобку, а потом { */\r\n    isAuth: state.auth.isAuth\r\n});\r\n\r\nexport const withAuthRedirect = (Component) => {\r\n    class RedirectComponent extends React.Component {\r\n        render() {\r\n            console.log(this.props)\r\n            if (!this.props.isAuth) return <Redirect to={\"/login\"}/>; /*запись (!this.props.isAuth) равна записи (this.props.isAuth === false) */\r\n\r\n            return <Component {...this.props} />\r\n        }\r\n    }\r\n\r\n\r\n\r\n    let ConnectedAuthRedirectComponent = connect(mapStateToPropsTForRedirect)(RedirectComponent);\r\n    return ConnectedAuthRedirectComponent;\r\n}\r\n","import React from 'react';\r\nimport DialogItem from \"./DialogItems/DialogItem\";\r\nimport Message from \"./Messages/Message\";\r\nimport {addMessageActionCreator, /*updateNewMessageTextActionCreator*/} from \"../../redux/dialogs-reducer\";\r\nimport Dialogs from './Dialogs';\r\nimport {connect} from \"react-redux\";\r\nimport {withAuthRedirect} from \"../../hoc/withAuthRedirect\";\r\nimport {compose} from \"redux\";\r\n\r\n\r\nconst DialogsContainerBackUp = (props) => {\r\n\r\n    let dialogElements = props.state.dialogs.map( (d) => <DialogItem id={d.id} name={d.name} profileImage={d.profileImage} /> ); //метод map - это страндартный метод любого массива. Он перебирает все данные массива и изменяет их по заданному шаблону. Метод map принимает значение стрелочной функции с передаваемым в нее параметром. Передававемым параметром является Элемент изменяемого массива. Т.е., обращаесь в передаваемой переменной ты образается к каждому элементу изменяемого массива. В теле функции прописываем что должны получить в результате для каждого 1-го элемента массива.\r\n    let messagesElement = props.state.messages.map (m => <Message id={m.id} message={m.message} sender={m.sender} profileImage={m.profileImage} />  ); //метод map - это страндартный метод любого массива. Он перебирает все данные массива и изменяет их по заданному шаблону. Метод map принимает значение стрелочной функции с передаваемым в нее параметром. Передававемым параметром является Элемент изменяемого массива. Т.е., обращаесь в передаваемой переменной ты образается к каждому элементу изменяемого массива. В теле функции прописываем что должны получить в результате для каждого 1-го элемента массива.\r\n\r\n    /*let newMessageElement = React.createRef(); /* Получение данных со строницы. Создаем переменную и присваеваем ей React.createRef(). Приваеваем эту переменную элемену HTML аналогично id='', но следующим синтаксисом ref={newPostElement}. После этого данная переменная будет содержать в себе элемент HTML и можно ображаться к его значению value через синтаксис newPostElement.current.value */\r\n\r\n    let sendMessageClick = () => {\r\n            props.store.dispatch(addMessageActionCreator())\r\n        }\r\n\r\n\r\n\r\n    return (\r\n        <Dialogs  sendMessageClick={sendMessageClick} state={props.state}  />\r\n\r\n\r\n    )\r\n}\r\n\r\n\r\nlet mapStateToProps = (state) => {\r\n    return {\r\n        /*state: state*/\r\n        /*posts: state.profilePage.posts,*/\r\n        dialogsPage: state.dialogsPage\r\n    }\r\n}\r\n\r\nlet mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        sendMessageClick: (newMessageBody) => {\r\n            dispatch(addMessageActionCreator(newMessageBody))\r\n        }\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\nexport default compose( /*compose позволяет запускать по очереди разные функции, чтобы они выпонлялись по очереди беря в качесвет параметра результат предыдущей функции*/\r\n    connect(mapStateToProps, mapDispatchToProps),\r\n    withAuthRedirect\r\n)\r\n(Dialogs) /*compose передаст то что указано здесь как параметр фонкции из списка выше*/"],"sourceRoot":""}